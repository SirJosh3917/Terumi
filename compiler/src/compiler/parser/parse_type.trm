use std
use compiler
use compiler.lexer

/**
 * This will attempt to parse parse what is defined in code as a "Type".
 * Types look like this:
 * Name
 * Name[]
 * Name<T>
 * Name<T>[]
 * Name<T1, T2>
 * Name<More<Stuff>[], number[]>[]
 */
ParseTypeResult parse_type(ContractLexer lexer)
{
	Token primary_part = lexer_next_significant(lexer)

	if (!primary_part.is_identifier()) {
		return new ParseTypeResult(false)
	}
	
	// now, parse the other possible tokens
	Token next = lexer_next_significant(lexer)
	
	LinkedParsedTypeList generics = new LinkedParsedTypeList()
	bool is_generic = false
	
	if (next.is_special("<")) {
		is_generic = true

		// need to parse generics
		ParseTypeResult result = parse_type(lexer)
		
		if (!result.success) {
			return new ParseTypeResult(false)
		}
		
		generics.add(result.data)
		
		next = lexer_next_significant(lexer)
		
		while (next.is_special(",")) {
			result = parse_type(lexer)
			
			if (!result.success) {
				return new ParseTypeResult(false)
			}
			
			generics.add(result.data)
			
			next = lexer_next_significant(lexer)
		}
		
		if (!next.is_special(">")) {
			return new ParseTypeResult(false)
		}
		
		next = lexer_next_significant(lexer)
	}
	
	bool is_array = false
	
	if (next.is_special("[")) {
		is_array = true
		
		next = lexer_next_significant(lexer)
		
		// we must have a closing ]
		if (!next.is_special("]")) {
			// TODO: fail parsing
			return new ParseTypeResult(false)
		}
		
		next = lexer_next_significant(lexer)
	}
	
	lexer.scan_to(next)
	return new ParseTypeResult(new ParsedType(is_array, is_generic, generics, primary_part.source))
}

class ParseTypeResult
{
	bool success
	ParsedType data

	ctor(bool param_success) {
		success = param_success
	}
	
	ctor(ParsedType param_data) {
		success = true
		data = param_data
	}
}

class ParsedType
{
	bool is_array
	bool is_generic
	LinkedParsedTypeList generics
	Text name

	ctor(bool param_is_array, Text param_name) {
		is_array = param_is_array
		is_generic = false
		name = param_name
	}

	ctor(bool param_is_array, bool param_is_generic, LinkedParsedTypeList param_generics, Text param_name) {
		is_array = param_is_array
		is_generic = param_is_generic
		generics = param_generics
		name = param_name
	}
}