use compiler.testing
use compiler.lexer
use compiler.parser
use compiler.parser.expressions

class ParseExpressionTests
{
	string test_group
	ContractTestHelper runner

	ctor() {
		test_group = "parse_expression"
	}
	
	begin(string name) runner.begin(name)
	assert(bool condition) runner.assert(condition)
	
	test(ContractTestHelper test_runner) {
		runner = test_runner
		
		begin("fails on ''")
		ParseExpressionResult result = parse_expression(new Lexer(""))
		assert(result.success == false)
		
		begin("fails on invalid expression \{")
		result = parse_expression(new Lexer("\{"))
		assert(result.success == false)
		
		begin("passes on identifier")
		result = parse_expression(new Lexer("identifier"))
		assert(result.success == true)
		assert(result.expression.equals(
			identifier("identifier")
		))
		
		begin("passes on true")
		result = parse_expression(new Lexer("true"))
		assert(result.success == true)
		assert(result.expression.equals(
			identifier("true")
		))
		
		begin("passes on false")
		result = parse_expression(new Lexer("false"))
		assert(result.success == true)
		assert(result.expression.equals(
			identifier("false")
		))
		
		begin("passes on whole number")
		result = parse_expression(new Lexer("123"))
		assert(result.success == true)
		assert(result.expression.equals(
			numerical(123)
		))
		
		begin("passes on negative whole number")
		result = parse_expression(new Lexer("-123"))
		assert(result.success == true)
		assert(result.expression.equals(
			negate(numerical(123))
		))
		
		begin("passes on decimal")
		result = parse_expression(new Lexer("123.456"))
		assert(result.success == true)
		
		begin("passes on negative decimal")
		result = parse_expression(new Lexer("-123.456"))
		assert(result.success == true)
		
		begin("passes on identifier member access")
		result = parse_expression(new Lexer("identifier.another_identifier"))
		assert(result.success == true)
		
		begin("passes on = assignment")
		result = parse_expression(new Lexer("identifier = 123"))
		assert(result.success == true)
		
		begin("passes on member access = assignment")
		result = parse_expression(new Lexer("identifier.another = 123"))
		assert(result.success == true)
		
		begin("passes on += assignment")
		result = parse_expression(new Lexer("identifier += 123"))
		assert(result.success == true)
		
		begin("passes on member access += assignment")
		result = parse_expression(new Lexer("identifier.another += 123"))
		assert(result.success == true)
		
		begin("passes on -= assignment")
		result = parse_expression(new Lexer("identifier -= 123"))
		assert(result.success == true)
		
		begin("passes on member access -= assignment")
		result = parse_expression(new Lexer("identifier.another -= 123"))
		assert(result.success == true)
		
		begin("passes on addition")
		result = parse_expression(new Lexer("1 + 2"))
		assert(result.success == true)
		assert(result.expression.equals(
			addition(
				numerical(1),
				numerical(2)
			)
		))
		
		begin("passes on subtraction")
		result = parse_expression(new Lexer("1 - 2"))
		assert(result.success == true)
		assert(result.expression.equals(
			subtraction(
				numerical(1),
				numerical(2)
			)
		))
		
		begin("passes on multiplication")
		result = parse_expression(new Lexer("1 * 2"))
		assert(result.success == true)
		
		begin("passes on division")
		result = parse_expression(new Lexer("1 / 2"))
		assert(result.success == true)
		
		begin("passes on modulus")
		result = parse_expression(new Lexer("1 % 2"))
		assert(result.success == true)
		
		begin("parses math in right precedence order")
		result = parse_expression(new Lexer("1 + 2 - 3 * 4 / 5 + 2 / 5 - 8 * 11"))
		assert(result.success == true)
		
		begin("parses equal to ==")
		result = parse_expression(new Lexer("true == true"))
		assert(result.success == true)
		assert(result.expression.equals(
			equals(identifier("true"), identifier("true"))
		))
		
		begin("parses not equal to !=")
		result = parse_expression(new Lexer("true != false"))
		assert(result.success == true)
		assert(result.expression.equals(
			not_equals(identifier("true"), identifier("false"))
		))
		
		begin("parses not !")
		result = parse_expression(new Lexer("!true"))
		assert(result.success == true)
		assert(result.expression.equals(
			negate(identifier("true"))
		))
		
		begin("parses and &&")
		result = parse_expression(new Lexer("true && true"))
		assert(result.success == true)
		assert(result.expression.equals(
			and(identifier("true"), identifier("true"))
		))
		
		begin("parses or ||")
		result = parse_expression(new Lexer("false || true"))
		assert(result.success == true)
		assert(result.expression.equals(
			or(identifier("false"), identifier("true"))
		))
		
		begin("parses equality in right precedence order")
		result = parse_expression(new Lexer("true && false || true == false && true == false || false || true && false == true || false"))
		assert(result.success == true)
		
		begin("parses parenthetical expression 1")
		result = parse_expression(new Lexer("(1)"))
		assert(result.success == true)
		assert(result.expression.equals(
			parenthetical(numerical(1))
		))
		
		begin("parses parenthetical expression true")
		result = parse_expression(new Lexer("(true)"))
		assert(result.success == true)
		assert(result.expression.equals(
			parenthetical(identifier("true"))
		))
		
		begin("parses parenthetical expression before non parenthetical expressions")
		result = parse_expression(new Lexer("true && (false == true) || (!false == (!true && false))"))
		assert(result.success == true)
	}
}