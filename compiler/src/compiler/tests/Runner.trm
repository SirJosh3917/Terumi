use std
use terumi

run_tests()
{
	Runner runner = new Runner()
	runner.self = runner
	
	runner.run(new StringTests(runner))
	runner.run(new TextTests(runner))
	runner.run(new LexerTests(runner))
}

class TestInfo
{
	string test_name
	number assertions
	bool failed

	ctor(string param_test_name) {
		test_name = param_test_name
		assertions = 0
		failed = false
	}
}

class Runner
{
	ctor()
	{
		_called_being = false
		_called_done = false
		
		println("
[Terumi Compiler Tests]

The Terumi Compiler tests as much of its code as it can, at runtime, when you
run it. The reason tests are ran not at compile time, is because there is no
infrastructure setup.

If you're seeing this message, chances are, you explicitly enabled testing - or
the project is still in its infancy.
")
	}
	
	Runner self
	TestInfo _test_info
	bool _called_being
	bool _called_done
	
	run(ContractTestable suite) {
		println("[{suite.test_group}]")
		suite.test()
		done()
	}
	
	begin(string test_name) {
		if (_called_being) if (!_called_done) done()
		
		_called_being = true
		_called_done = false
	
		_test_info = new TestInfo(test_name)
	}
	
	assert(bool condition) {
		if (!_test_info.failed) {
			_test_info.assertions = _test_info.assertions + 1
		}
		
		if (!condition) {
			_test_info.failed = true
		}
	}
	
	assert(string description, bool condition) {
		assert(condition)
	}
	
	done() {
		_called_done = true
		@println("{_tab_or_failed(_test_info.failed)}{_test_info.test_name} - {_bool_to_passed_or_not(_test_info.failed)}, {_info_assertions()}")
	}
	
	string _tab_or_failed(bool failed) {
		if (failed) {
			return "X	"
		}
		
		return "	"
	}
	
	string _info_assertions() {
		if (_test_info.failed) {
			return "failed on assertion {to_string(_test_info.assertions)}"
		}
		
		return "{to_string(_test_info.assertions)} assertions"
	}
}

string _bool_to_passed_or_not(bool failed) {
	if (!failed) return "passed"
	return "FAILED"
}

class ContractTestable
{
	string test_group

	test() {
		@panic("Contract 'ContractTestable' may not be used.")
	}
}